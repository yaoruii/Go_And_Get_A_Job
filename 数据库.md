# 数据库系统原理

## 一、事务
概念：事务是一个满足ACID特性的操作序列，不可分割的工作单元，以begin transaction开始，以**rollback/commit结束**。

**ACID:**
* Atomicity（原子性）：事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。
* consistency（一致性）：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对同一个数据读取结果都是一样的
* Isolation（隔离性）：一个事务所做的修改在最终提交之前，对其他事务不可见。
* Durability(持久性）：一旦事务提交，则其所做的修改就会永久地保存在数据库中。即使系统崩溃，事务执行的结果也不会消失。
系统崩溃后，可以用**重做日志**进行恢复，从而实现持久性。

## 二、并发一致性问题
**在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题**

### 丢失修改
T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf12pfu7hyj30tu0hiaaq.jpg)

### 读脏数据
T1 修改一个数据，但未提交，或者 T1 撤销了这次修改，T2 随后读取这个数据，那么 T2 读取的数据是脏数据。造成两个事务得到的数据不一致；

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf138bgayaj30r10mygmh.jpg)

### 不可重复度
在**同一个事务中**，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（**可能是被另一个事务更新或者被删除）**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf17rhsjlsj30ra0l1mxw.jpg)

### 幻读
当同一查询多次执行时，由于其他事务在这个数据范围内执行了**插入操作**，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf181yog18j30sb0kwt9o.jpg)

产生并发不一致性问题的主要因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。**并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。**

## 三，封锁
### 封锁粒度
MySQL中提供了两种封锁粒度：行级锁和表级锁。

尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生**锁争用的可能就越小，系统的并发程度就越高。**

但是加锁需要消耗资源，封锁粒度越小，开销越大。

**在选择封锁粒度时，需要在锁开销和并发程度之间做个权衡。**

### 封锁类型
锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性
#### 1，读写锁
* 互斥锁/排他锁：X锁，写锁
* 共享锁：S锁，读锁。

有以下两个规定：
* 一个事务对数据对象A加了X锁，就可以对A进行读取和更新，加锁期间，**其他事务不能对A加任何锁**
* 一个事务对A加了S锁，就可以对A进行读取，但不能更新。**加锁期间其他事务可以加S锁，但不能加X锁**。

#### 2，意向锁
可以更加容易地支持多粒度封锁

在存在行级和表级锁情况下，事务T想要对对象A加X锁，就需要先检测是否已经有事务对表A或者表A中的任意一行加了锁，那么就需要对表A的每一行都检测一次，非常耗时。

意向锁在原来的X/S基础上，引入了IX/IS锁，**IX/IS都是表锁**，用来表示一个事务想要在表中的某个数据行上加X/S锁：
* 一个事务在获得某个**数据行**对象的 S 锁之前，必须先获得**整个表**的IS锁或更强的锁；
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
* **这样加X锁之前**，只需要检测其他事务是否对表A加了IX/IS/S/X锁即可。如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，**因此事务 T 加 X 锁失败**。
* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
* 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

**什么是乐观锁和悲观锁？**
* 悲观锁：认为数据随时会被修改，因此每次**读取数据之前都会上锁，防止其他事务读取或者修改数据**；应用于**数据更新比较频繁的场景**；
* 乐观锁：操作数据时不会上锁，但是**更新时会判断在此期间有没有别的事务更新了这个数据，若被更新过，则失败重试**。适用于**读多写少**的场景（写很少，所以，只在写即更新的时候加锁保护以下，读的时候就不许需要了）

### 封锁协议
#### 1，三级封锁协议
* 一级封锁协议：事务在修改数据之前必须对其加X锁，**直到事务结束才释放**。可以解决数据丢失的问题：两个事务不能同时对同一个数据加X锁，因为数据不会被第二个事务修改。
* 二级封锁协议：在一级的基础上，事务在读物数据之前必须要加S锁，**读完后释放**。可以避免脏读的问题，因为如果已经有事务在修改数据，说明一定已经加了X锁，那么该事务就无法加S锁，也就无法读取，因此避免了读取脏数据。
* 三级封锁协议：在二级的基础上，事务在读取数据之前，必须先加S锁，事务结束后释放。避免了不可重复度问题。因为在该事务提交前，其他事务只能对数据加S锁，不能加X锁进行修改，保证了事务期间数据不会被其他事务更新。

#### 2，两段锁协议
加锁和解锁分两个阶段进行。第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

事务遵循两段锁协议是保证可串行化调度的充分条件。

### MySQL隐式与显式锁定


## 四，隔离级别
* 1，未提交读：在一个事务被提交之前，它的执行结果对其他事务也是可见的。会导致脏读、不可重复读、幻读。
* 2，提交读：一个事务只能看见已经提交的事务所做的改变。可避免脏读。
* 3，可重复读：可以确保同一个事务在多次读取同一个数据时得到相同的结果。可避免不可重复读。
* 4，可串行化：强制事务串行执行，使之不可能相互冲突，从而解决了幻读的问题。实际很少使用，可能会导致大量的超时现象和锁竞争。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf182k0kl9j30v10gb0u1.jpg)


## 五，多版本并发控制
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎**实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。**
### 基本思想
加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的。

 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
 
 在MVCC中事务的修改操作（delete、insert、update）会为数据行新增一个版本快照。
 
为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读

### 版本号
* 系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
* 事务版本号：**事务开始时的系统版本号。**

### undo日志
MVCC的多版本指的是：多个版本的快照，快照存储在undo日志中，该日志通过回滚指针ROLL_PTR将一个数据行的所有快照连接起来。

快照中除了记录事务版本号TRX_ID和操作之外，还记录一个bit的DEL字段，用于标记是否被删除。
* 创建版本号：创建一个数据行时的事务版本号。
* 删除版本号：删除操作时的事务版本号
* 各种操作：
   * 插入：记录创建版本号
   * 删除：记录删除版本号
   * 更新：先记录删除版本号，再新增一行记录创建版本号。
   * 查询：要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号(说明删除操作是在当前事务启动之后做的）；创建版本号小于或者等于当前事务版本号（创建操作的事务完成或者在事务启动之前完成）

通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读这种隔离级别，未提交读无需使用MVCC。

**快照读**
MVCC的select操作是快照中的数据，不需要进行加锁操作。

**当前读：**
MVCC其他会对数据库进行修改的操作（insert、update、delete），需要进行加锁，从而读取最新的数据。可以看到MVCC并不是完全不用加锁，而只是避免了SELECT的加锁操作。

## 六、Next-Key Locks


## 七、关系数据库设计理论
### 函数依赖
即A->B表示A函数决定B，也可以说B函数依赖于A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，**该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。比如，学生和课程的依赖关系：{Sno, Cname} -> {Sname, Sdept, Mname, Grade}，确定了学生的学号和课程的名字后，其他的信息：学生的名字、学生所在系、学院的院长名字、这门课的考试成绩，就都确定了。**

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

### 异常
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf28kyy20vj30p60aimyn.jpg)

不符合范式的关系，会产生很多异常，主要有以下四种异常：
* 冗余数据：某些同样的数据多次出现（如学生姓名）
* 修改异常：修改了一个记录里的信息，另一个记录中相同的信息却没有修改。
* 删除异常：删除一个信息，那么也会丢失其他信息（删除一个课程，丢失了一个学生）
* 插入异常：无法插入（插入一个还没有课程信息的学生时无法插入）

### 范式
高级别范式的依赖于低级别的范式。1NF是最低级别的。

* 第一范式（1NF)：**属性是不可分的。**比如：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话/移动☎️，如果将移动☎️作为一个属性，就符合1NF。
* 第二范式（2NF)：**每个非主属性完全函数依赖于键码，注意是每一个非主属性**
    * B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则冗余（叫依赖，但是不是完全依赖）。举例：（学号，课程名）这一主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余，只需要学号即可确定学生姓名，所以学生姓名不完全依赖与（学号，课程名）这一属性集。
    * 主属性集/候选码集：某一组属性能够唯一确定其他的属性，而其子集不能，这样的属性组中的属性就是主属性，不在候选码集中的属性称为非主属性。
    * 可以通过分解来满足2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；
 * 第三范式3NF：**在2NF基础上，非主属性不传递依赖于主属性**
    * 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A
    * 消除了非主属性之间的依赖；比如：一个表中，主属性有学号，非主属性有姓名、院系、院长名，可以看到院长名这个属性是依赖于院系的，传递依赖于学号。
    * 通过分解来消除：将学院和院长名单做一张表，学号、学生姓名、院系号码作为另一张表。
    
 ## 八、ER图
 Entity-Relationship，有三个组成部分：实体、属性、联系。
 
 #### 实体的三种联系
 包含一对一，一对多，多对多三种。
 * 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；
 * 如果是一对一，画两个带箭头的线段；
 * 如果是多对多，画两个不带箭头的线段。


## 九、其他问题

### 连接
连接用于连接多个表，使用JOIN关键字，并且条件语句使用ON而不是WHERE

连接可以替换子查询，并且比子查询的效率更快

#### 内连接
内连接，等值连接，使用inner join关键词，并
* 不去掉重复的属性列：比如说如果连接条件是 t1.B = t2.B，并且```select *```，那么最后的表会包含t1.B 和 t2.B，且两者完全一样（因为是连接条件）
* where t1.C = t2.D，可以是不相同的属性名。
```
SELECT A.value, B.value
FROM tablea AS A INNER JOIN tableb AS B
ON A.key = B.key;
```

可以不明确使用 INNER JOIN，而使用**普通查询**并在 WHERE 中将两个表中要连接的列用等值方法连接起来。

```
SELECT A.value, B.value
FROM tablea AS A, tableb AS B
WHERE A.key = B.key;//给定条件进行查询！！！！
```
#### 自连接
**可以看成内连接的一种，只是连接的表是自身而已**

一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。

子查询版本：
```
SELECT name
FROM employee
WHERE department = (
      SELECT department
      FROM employee
      WHERE name = "Jim");
```

自连接：
```
SELECT e1.name
FROM employee AS e1 INNER JOIN employee AS e2
ON e1.department = e2.department
      AND e2.name = "Jim";
```

#### 自然连接
把同名列通过等值测试连接起来，同名列可以有多个。

内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接同名的列
```
SELECT A.value, B.value
FROM tablea AS A NATURAL JOIN tableb AS B;
```
* B是两个表的同名属性，相当于等值连接的```where t1.B = t2.B```，但是最后的结果中，只有一列B。
* 自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接

#### 外连接

外连接保留没有关联的那些行。分为左外连接，右外连接以及全外连接。

左外连接就是保留左表没有关联的行。LEFT OUTER JOIN

检索所有顾客的订单信息，包括还没有订单信息的顾客，这样左表是顾客信息，右表是订单信息，保留没有出现在右表中但是出现在左表中的顾客的信息，缺失的订单信息用**null补充**。

右连接：和左连接相反。RIGHT OUTER JOIN

全外连接：查询出左表和右表所有的数据，但是去除两表的重复数据 FULL OUTER JOIN

#### 交叉连接：返回两表的笛卡尔积。

### 存储过程
存储过程是**事先经过编译并存储在数据库中的一段SQL语句的集合**。想要实现相应的功能时，只需要调用这个存储过程就行了。

好处：
* 预先编译，而不需要每次运行时编译，**提高了数据库执行的效率**
* 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，**可以减少网络通信量。**
* 可复用性
* 安全性高
* 更易于维护。

缺点：
* 可移植性差，将应用程序绑定在数据库内。
* 开发调试复杂
* 修改复杂，需要重新编译，有时还需要更新程序中的代码以更新调用。

### 触发器
触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。

触发器必须指定在语句执行之前还是之后自动执行，之前执行使用BEFORE关键字，用于数据验证与净化。之后执行使用AFTER关键字，用于审计跟踪，将修改记录到另外一张表中。

NSERT 触发器包含一个名为 NEW 的虚拟表。DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。

**有哪些约束条件？**
约束类型：主键（primary key）约束，唯一约束，检查约束、外键约束。

**Drop/delete/truncate的区别？**
* delete：用来删除表的全部或者部分数据，执行delete之后，用户需要提交之后才可以执行，会触发触发器，包含一个old的虚拟表，可以只读访问被删除的数据），delete后表的结构还在，删除很慢，一行一行删，会记录日志，可以利用日志还原数据。
* truncate：删除表中所有的数据，不能回滚，也不会触发这个表上的触发器，操作比delete快很多，直接把表drop掉，再创建一个新表，删除的数据不会被找到。
* drop：从数据库中删除表，所有的数据行，索引、约束都会被删除，不能回滚，不会触发触发器。

### 游标
用于定位在**查询返回的结果集的特定行，以对特定行进行操作**。使用游标可以**方便地对结果集进行移动遍历**，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。

### 视图
从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）

可以对其进行增/删/改/查等操作，对视图的修改不影响基本表。

好处：
* 通过只给用户访问视图的权限，保证数据的安全性。
* 简化复杂的SQL操作，隐藏数据的复杂性。

视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。

### 数据库索引实现原理（B+树）
索引是对数据库表中一列或多列的值进行排序的一种数据结构。

**为什么使用索引？**
* 通过**创建唯一性索引，可以保证数据库表中每一行数据的唯一性。**
* 可以大大加快 **数据的检索速度**（大大减少的检索的数据量）
* 显著减少了查询中**分组和排序**的时间。
* 帮助服务器避免排序和临时表。
* 将随机IO变为顺序IO（B+tree索引是有序的，会将相邻的数据都存储在一起。）
* 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

**为什么不对表中每一个列都创建一个索引？（缺点）**
* 当对表中的数据进行增加、删除、修改的时候，索引也要动态地维护，降低了数据的维护速度。
* 索引需要占有物理**空间**，除了数据表占数据空间之外，每一个索引还要站一定的物理空间。
* 创建索引和维护索引需要**时间**，这种时间随着数据量的增加而增加。

**在哪些地方适合创建索引？**
* 某列经常作为最大组小值。
* 经常被查询的字段。
* 经常用作表连接的字段。
* 经常出现在ORDER BY/GROUP BY/DISTINCT 后面的字段。
* 在经常需要排序的列上创建索引。

**创建索引的时候需要注意什么？**
* 只应建立在**小字段**上，而不要对大文本或图片建立索引（一页存储的数据越多，一次IO操作获取的数据越多，效率越高）
* 不建议列上允许为null，最好限制为not null，null需要更多的存储空间，并且null值无法参与某些运算。
* 选择**数据密度大（唯一值占总数的百分比很大）**的字段作索引。
* 删除长期未使用的索引。

#### MySQL索引主要使用的两种数据结构：
**1，哈希索引：**

对于哈希索引来说，**底层的数据结构就是哈希表**，因此在绝大多数**需求为单条记录查询的时候，精准查找**，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B tree索引。无法用于部分查找和范围查找，不支持数据的排序。

**无法用于排序和分组**

**2，B+TREE 索引**

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

* B树的所有节点即存放 键(key)也存放 数据(data)；**而B+树只有叶子节点存放key和data，其他节点只存放key**
* B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
* B树的检索过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。B+树的检索效率更加稳定，任何查找都是从跟节点到叶子节点的过程，叶子节点的顺序检索很明显。

InnoDB的索引使用的是B+树实现，B+树对比B树的好处：
* IO次数少：B+树的中间节点只存放key索引，数据都存放在叶节点中，
* 范围查询效率更高：B树需要中序遍历整个树，B+树需要遍历叶节点中的链表。
* 查询效率更稳定：每次查询都需要从根节点到叶节点，路径长度相同，所以每次查询的效率都差不多。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

是大多数MySQL存储引擎的默认索引类型。不需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为B+ TREE的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

**哪种情况下索引会失效？**
* 以%开头的LIKE语句。
* OR语句前后没有同时使用索引。
* 数据类型出现隐式转换。
* 对于多列索引，必须满足 **最左匹配原则/最左前缀原则**
* 如果MySQL估计全表扫描比索引快，则不使用索引。（比如非常小的表）

**索引的分类？**
* 普通索引（属于辅助索引）
* 唯一索引 UNIQUE（属于辅助索引）：索引列的值必须唯一，不能重复，但允许有空置，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效
* 主键索引 PRIMARY KEY：必须唯一，不允许有空值，一种特殊的唯一索引。一张数据表有只能有一个主键，并且主键不能为null，不能重复。
* 单列索引和多列索引/复合索引：指的是索引的列数
* 覆盖索引：索引覆盖了所有需要查询的字段的值。查询的时候只需要读取索引而不需要回表读取数据；
* 聚集索引/非聚集索引：**对磁盘上存放的数据的物理地址重新组织**以使这些数据**按照指定规则排序**的一种索引。**主键索引属于聚集索引**，数据的物理排列顺序和索引排列顺序一致，因此每张表只能创建一个聚集索引，因为要改变物理存储顺序。优点是：查询速度快，因为可以直接按照顺序得到需要的数据。缺点是修改速度慢。对于需要经常搜索范围的值很有效。非聚集索引只是记录逻辑顺序，并不改变物理顺序。
* 虚拟索引：模拟索引的存在而不是真正地创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不会增加存储空间的使用。

**MySQL的两种存储引擎InnoDB和MyISAM的区别？**
* innodb**支持事务**，可以进行commit和rollback
* MyISAM只支持表级锁，而InnoDB还支持行级锁，提高了并发操作的性能。
* Innodb支持外键：在student表中，通过class_id的字段，可以把数据与另一张表（表示班级信息的表）关联起来，这种列class_id就被称为外键，通过定义**外键约束**实现：FOREIGN KEY (class_id)指定了class_id作为外键
* MyISAM 崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢；
* MyISAM 支持**压缩**表和空间数据索引，InnoDB需要更多内存。
* InnoDB支持在线**热备份**。

**热备份与冷备份：**
* 热备份：在数据库运行的情况下备份的方法。
