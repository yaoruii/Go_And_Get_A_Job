# 数据库系统原理

## 一、事务
概念：事务是一个满足ACID特性的操作序列，不可分割的工作单元，以begin transaction开始，以**rollback/commit结束**。

**ACID:**
* Atomicity（原子性）：事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。
* consistency（一致性）：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对同一个数据读取结果都是一样的
* Isolation（隔离性）：一个事务所做的修改在最终提交之前，对其他事务不可见。
* Durability(持久性）：一旦事务提交，则其所做的修改就会永久地保存在数据库中。即使系统崩溃，事务执行的结果也不会消失。
系统崩溃后，可以用**重做日志**进行恢复，从而实现持久性。

## 二、并发一致性问题
**在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题**

### 丢失修改
T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf12pfu7hyj30tu0hiaaq.jpg)

### 读脏数据
T1 修改一个数据，但未提交，或者 T1 撤销了这次修改，T2 随后读取这个数据，那么 T2 读取的数据是脏数据。造成两个事务得到的数据不一致；

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf138bgayaj30r10mygmh.jpg)

### 不可重复度
在**同一个事务中**，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（**可能是被另一个事务更新或者被删除）**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf17rhsjlsj30ra0l1mxw.jpg)

### 幻读
当同一查询多次执行时，由于其他事务在这个数据范围内执行了**插入操作**，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf181yog18j30sb0kwt9o.jpg)

产生并发不一致性问题的主要因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。**并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。**

## 三，封锁
### 封锁粒度
MySQL中提供了两种封锁粒度：行级锁和表级锁。

尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生**锁争用的可能就越小，系统的并发程度就越高。**

但是加锁需要消耗资源，封锁粒度越小，开销越大。

**在选择封锁粒度时，需要在锁开销和并发程度之间做个权衡。**

### 封锁类型
锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性
#### 1，读写锁
* 互斥锁/排他锁：X锁，写锁
* 共享锁：S锁，读锁。

有以下两个规定：
* 一个事务对数据对象A加了X锁，就可以对A进行读取和更新，加锁期间，**其他事务不能对A加任何锁**
* 一个事务对A加了S锁，就可以对A进行读取，但不能更新。**加锁期间其他事务可以加S锁，但不能加X锁**。

#### 2，意向锁
可以更加容易地支持多粒度封锁

在存在行级和表级锁情况下，事务T想要对对象A加X锁，就需要先检测是否已经有事务对表A或者表A中的任意一行加了锁，那么就需要对表A的每一行都检测一次，非常耗时。

意向锁在原来的X/S基础上，引入了IX/IS锁，**IX/IS都是表锁**，用来表示一个事务想要在表中的某个数据行上加X/S锁：
* 一个事务在获得某个**数据行**对象的 S 锁之前，必须先获得**整个表**的IS锁或更强的锁；
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
* **这样加X锁之前**，只需要检测其他事务是否对表A加了IX/IS/S/X锁即可。如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，**因此事务 T 加 X 锁失败**。
* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
* 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

### 封锁协议
#### 1，三级封锁协议
* 一级封锁协议：事务在修改数据之前必须对其加X锁，**直到事务结束才释放**。可以解决数据丢失的问题：两个事务不能同时对同一个数据加X锁，因为数据不会被第二个事务修改。
* 二级封锁协议：在一级的基础上，事务在读物数据之前必须要加S锁，**读完后释放**。可以避免脏读的问题，因为如果已经有事务在修改数据，说明一定已经加了X锁，那么该事务就无法加S锁，也就无法读取，因此避免了读取脏数据。
* 三级封锁协议：在二级的基础上，事务在读取数据之前，必须先加S锁，事务结束后释放。避免了不可重复度问题。因为在该事务提交前，其他事务只能对数据加S锁，不能加X锁进行修改，保证了事务期间数据不会被其他事务更新。

#### 2，两段锁协议
加锁和解锁分两个阶段进行。第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

事务遵循两段锁协议是保证可串行化调度的充分条件。

### MySQL隐式与显式锁定


## 四，隔离级别
* 1，未提交读：在一个事务被提交之前，它的执行结果对其他事务也是可见的。会导致脏读、不可重复读、幻读。
* 2，提交读：一个事务只能看见已经提交的事务所做的改变。可避免脏读。
* 3，可重复读：可以确保同一个事务在多次读取同一个数据时得到相同的结果。可避免不可重复读。
* 4，可串行化：强制事务串行执行，使之不可能相互冲突，从而解决了幻读的问题。实际很少使用，可能会导致大量的超时现象和锁竞争。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf182k0kl9j30v10gb0u1.jpg)


## 五，多版本并发控制
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎**实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。**
### 基本思想
加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的。

 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
 
 在MVCC中事务的修改操作（delete、insert、update）会为数据行新增一个版本快照。
 
为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读

### 版本号
* 系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
* 事务版本号：**事务开始时的系统版本号。**

### undo日志
MVCC的多版本指的是：多个版本的快照，快照存储在undo日志中，该日志通过回滚指针ROLL_PTR将一个数据行的所有快照连接起来。

快照中除了记录事务版本号TRX_ID和操作之外，还记录一个bit的DEL字段，用于标记是否被删除。
* 创建版本号：创建一个数据行时的事务版本号。
* 删除版本号：删除操作时的事务版本号
* 各种操作：
   * 插入：记录创建版本号
   * 删除：记录删除版本号
   * 更新：先记录删除版本号，再新增一行记录创建版本号。
   * 查询：要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号(说明删除操作是在当前事务启动之后做的）；创建版本号小于或者等于当前事务版本号（创建操作的事务完成或者在事务启动之前完成）

通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读这种隔离级别，未提交读无需使用MVCC。

**快照读**
MVCC的select操作是快照中的数据，不需要进行加锁操作。

**当前读：**
MVCC其他会对数据库进行修改的操作（insert、update、delete），需要进行加锁，从而读取最新的数据。可以看到MVCC并不是完全不用加锁，而只是避免了SELECT的加锁操作。

## 六、Next-Key Locks


## 七、关系数据库设计理论
### 函数依赖
即A->B表示A函数决定B，也可以说B函数依赖于A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，**该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。比如，学生和课程的依赖关系：{Sno, Cname} -> {Sname, Sdept, Mname, Grade}，确定了学生的学号和课程的名字后，其他的信息：学生的名字、学生所在系、学院的院长名字、这门课的考试成绩，就都确定了。**

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

### 异常
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf28kyy20vj30p60aimyn.jpg)

不符合范式的关系，会产生很多异常，主要有以下四种异常：
* 冗余数据：某些同样的数据多次出现（如学生姓名）
* 修改异常：修改了一个记录里的信息，另一个记录中相同的信息却没有修改。
* 删除异常：删除一个信息，那么也会丢失其他信息（删除一个课程，丢失了一个学生）
* 插入异常：无法插入（插入一个还没有课程信息的学生时无法插入）

### 范式
高级别范式的依赖于低级别的范式。1NF是最低级别的。

* 第一范式（1NF)：**属性是不可分的。**比如：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话/移动☎️，如果将移动☎️作为一个属性，就符合1NF。
* 第二范式（2NF)：**每个非主属性完全函数依赖于键码，注意是每一个非主属性**
    * B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则冗余（叫依赖，但是不是完全依赖）。举例：（学号，课程名）这一主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余，所以学生姓名不完全依赖与（学号，课程名）这一属性集。
    * 主属性集/候选码集：某一组属性能够唯一确定其他的属性，而其子集不能，这样的属性组中的属性就是主属性，不在候选码集中的属性称为非主属性。
    * 可以通过
