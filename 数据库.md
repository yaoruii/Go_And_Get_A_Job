# 数据库系统原理

## 一、事务
概念：事务是一个满足ACID特性的操作序列，不可分割的工作单元，以begin transaction开始，以rollback/commit结束。

**ACID:**
* Atomicity（原子性）：事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。
* consistency（一致性）：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对同一个数据读取结果都是一样的
* Isolation（隔离性）：一个事务所做的修改在最终提交之前，对其他事务不可见。
* Durability(持久性）：一旦事务提交，则其所做的修改就会永久地保存在数据库中。即使系统崩溃，事务执行的结果也不会消失。
系统崩溃后，可以用**重做日志**进行恢复，从而实现持久性。

## 二、并发一致性问题
**在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题**

### 丢失修改
T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf12pfu7hyj30tu0hiaaq.jpg)

### 读脏数据
T1 修改一个数据，但未提交，或者 T1 撤销了这次修改，T2 随后读取这个数据，那么 T2 读取的数据是脏数据。造成两个事务得到的数据不一致；

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf138bgayaj30r10mygmh.jpg)

### 不可重复度
在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（**可能是被另一个事务更新或者被删除）**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf17rhsjlsj30ra0l1mxw.jpg)

### 幻读
当同一查询多次执行时，由于其他事务在这个数据范围内执行了**插入操作**，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf181yog18j30sb0kwt9o.jpg)

产生并发不一致性问题的主要因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。**并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。**

## 三，封锁
### 封锁粒度
MySQL中提供了两种封锁粒度：行级锁和表级锁。

尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生**锁争用的可能就越小，系统的并发程度就越高。**

但是加锁需要消耗资源，封锁粒度越小，开销越大。

**在选择封锁粒度时，需要在锁开销和并发程度之间做个权衡。**

### 封锁类型
锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性
#### 1，读写锁
* 互斥锁/排他锁：X锁，写锁
* 共享锁：S锁，读锁。

有以下两个规定：
* 一个事务对数据对象A加了X锁，就可以对A进行读取和更新，加锁期间，**其他事务不能对A加任何锁**
* 一个事务对A加了S锁，就可以对A进行读取，但不能更新。**加锁期间其他事务可以加S锁，但不能加X锁**。

#### 2，意向锁
可以更加容易地支持多粒度封锁

在存在行级和表级锁情况下，事务T想要对对象A加X锁，就需要先检测是否已经有事务对表A或者表A中的任意一行加了锁，那么就需要对表A的每一行都检测一次，非常耗时。

意向锁在原来的X/S基础上，引入了IX/IS锁，**IX/IS都是表锁**，用来表示一个事务想要在表中的某个数据行上加X/S锁：
* 一个事务在获得某个**数据行**对象的 S 锁之前，必须先获得**整个表**的IS锁或更强的锁；
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
* **这样加X锁之前**，只需要检测其他事务是否对表A加了IX/IS/S/X锁即可。如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，**因此事务 T 加 X 锁失败**。
* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
* 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

### 封锁协议
#### 1，三级封锁协议
* 一级封锁协议：事务在修改数据之前必须对其加X锁，直到事务结束才释放。可以解决数据丢失的问题：两个事务不能同时对同一个数据加X锁，因为数据不会被第二个事务修改。
* 二级封锁协议：在一级





## 四，隔离级别
* 1，未提交读：在一个事务被提交之前，它的执行结果对其他事务也是可见的。会导致脏读、不可重复读、幻读。
* 2，提交读：一个事务只能看见已经提交的事务所做的改变。可避免脏读。
* 3，可重复读：可以确保同一个事务在多次读取同一个数据时得到相同的结果。可避免不可重复读。
* 4，可串行化：强制事务串行执行，使之不可能相互冲突，从而解决了幻读的问题。实际很少使用，可能会导致大量的超时现象和锁竞争。该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gf182k0kl9j30v10gb0u1.jpg)



