1. 位图这样的数据结构在操作系统当中: 磁盘空间的管理

2. 1GB=1024MB，1MB=1024KB，1KB=1024B，1B（字节）=8bits（比特），所以1GB=1024MB

#### 操作系统的四个特性
- 1，**并发**：一段时间内运行多个程序。但其实在任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的。操作系统通过引入进程和线程，使得程序能够并发运行。
  并行是同一个时刻运行多个指令。而并行：在多CPU系统中，多个程序无论宏观上还是微观上都是同时执行的
- 2,**共享**：系统中的资源可以被多个并发进程共同使用。两种共享方式：
  * 互斥共享：互斥共享的资源称为临界资源，例如，打印机等，在同一个时刻只允许一个进程访问，需要同步机制来实现互斥访问
  * 同时共享
- 3，**虚拟**：把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：
   * 时（时间）分复用技术：多个进程能在同一个处理器上并发地执行，使用了时分复用，每一个进程轮流占用处理器，每次只执行一小个时间片并快速切。
   * 空（空间）分复用技术：虚拟内存:
      * 虚拟内存被组织成一个存放在磁盘上的N个连续的字节大小的单元组成的数组。在存储器结构中，较低层次上的磁盘数据被分割成快，这些块是和较高层次的主存之间的传输单元。主存是虚拟内存的缓存。
      * 虚拟内存被分割成虚拟页，在任意时刻，分为：未被分配的：还未分配或创建的页，没有任何数据和他们关联，因此不占用任何内存空间、缓存的：目前已经缓存在物理内存中的已分配页、未缓存的：未缓存在物理内存的已分配页。
      * 将物理空间抽象未地址空间，每个进程都有各自的地址空间，地址空间被分成大小相等的页，页被映射到物理内存。不需要将所有的页缓存在内存中。当程序引用到不在物理内存中的为缓存的页时，操作系统执行页面置换算法，将该页置换到内存中。对于程序来说，似乎有很大的内存空间，但实际上有一部分是存储在磁盘上的。
      
- 4，异步：指进程不是一次性执行完毕，而是走走停停，以不可知的速度往前推进。

#### 操统的功能
* 进程管理：控制、同步、通信、死锁处理、处理机调度
* 进程管理：
* 内存管理：内存分配、地址映射、内存保护与共享、虚拟内存
* 文件管理：存储空间的管理，目录管理、文件读写管理和保护
* 设备管理：完成用户的I/O请求，方便用户使用各种设备，提高设备的利用率：缓存管理、设备分配、设备处理、虚拟设备等。

# 进程管理
## 进程与线程
### 1，进程：process
资源分配的基本单元。进程控制块（PCB）描述进程的基本信息和运行状态，创建和撤销进程，都是对PCB的操作。
### 2，线程：thread
线程是独立调度的基本单元。一个进程可以有多个线程，他们共享进程的资源。
### 3，区别
* **进程拥有系统资源的一个独立单位，而线程基本上不拥有系统资源，只拥有一点运行中必不可少的资源（计数器，寄存器、栈），和其他线程共享进程的资源（内存，I/O，CPU）**
* 在进程切换中，涉及到当前执行进程CPU环境的保存和新调度进程CPU环境的设置，而同一个进程中的线程在切换时不会引起进程的切换，只需保存和设置少量的寄存器的内容，不同进程的线程切换时，涉及到进程切换。
* 系统
* 调度；在进程切换中，涉及到当前执行进程CPU环境的保存和新调度进程CPU环境的设置，而同一个进程中的线程在切换时不会引起进程的切换，只需保存和设置少量的寄存器的内容，不同进程的线程切换时，涉及到进程切换。
* 开销：creat or delete 进程时，系统都要为之分配or回收资源，如内存空间、I/O设备等，开销很大，切换进程时也是，而相比之下，线程的开销很小。
* 通信：线程间可以通过**直接读写同一进程中的数据进行通信，但是进程之间需要借助IPC的方式通信**
* 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但是多进程程序中一个进程崩溃并不会对其他进程造成影响，**因为进程有自己的独立地址空间，多进程更加健壮。线程共享所属进程的地址空间。

## 进程状态的切换：
* 就绪状态（ready）：等待被调度
* 运行状态（running）
* 阻塞状态（waiting）：等待资源
注意：⚠️
* 只有就绪和运行状态可以相互转换，其他之间都是单向转换。就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态。而运行状态，在分配给它的CPU时间用完后会转为就绪状态，等待下一次的调度。
* 阻塞状态是缺少需要的资源从而由运行状态转换而来，但该资源不包括CPU时间，缺少CPU时间，会转为就绪状态。
## 进程调度算法：
### 1，批处理系统
没有太多的用户操作，调度算法的目标是：保证吞吐量和周转时间
**1.1，先来先服务first-come first serverd: FCFS**
非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，不利于短作业，因为短作业需要等待前边的长作业执行完毕才能执行，而长作业执行时间长，造成了短作业等待时间过长。
**1.2，短作业优先 short job first:sjf**
非抢占式的调度算法，按估计运行时间



